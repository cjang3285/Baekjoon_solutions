#include <bits/stdc++.h>
using namespace std;

// nCr 계산 함수
long long combination(int n, int r) {
    if (r > n - r) r = n - r; // 조합 대칭성 활용, r > n-r이면 n-r로 계산해도 값 동일

    long long res = 1;

    for (int i = 1; i <= r; i++) {

        // -----------------------------
        // 1️⃣ 잘못된 방식 1: 정수 나눗셈 먼저
        // res *= (n - i + 1) / i;
        // 해석: (n-i+1)/i가 int / int → 정수 나눗셈 먼저 수행
        //      소수부가 날아가고 결과 틀림
        // -----------------------------

        // -----------------------------
        // 2️⃣ 잘못된 방식 2: 캐스팅 시도
        // res *= (long long)(n - i + 1) / i;
        // 해석: (long long)(n-i+1)/i → 나눗셈이 먼저 처리됨
        //      long long / int이지만 정수 나눗셈은 이미 수행되므로
        //      소수부는 버려짐
        //      곱하기 전에 나눗셈이 끝나 값이 틀림
        // -----------------------------

        // -----------------------------
        // 3️⃣ 잘못된 방식 3: double 사용
        // double dres = 1;
        // dres = dres * (n - i + 1) / i;
        // 해석:
        // - double로 계산하면 소수 연산 사용
        // - 큰 수에서는 정밀도 손실로 인해 정확한 정수값이 깨짐
        // - 조합 계산은 정수 연산이 필수이므로 double은 안전하지 않음
        // -----------------------------

        // -----------------------------
        // 4️⃣ 올바른 방식: 곱하기 먼저, long long 사용
        res = res * (n - i + 1) / i;
        // 해석: 
        // - res * (n-i+1)가 long long으로 계산
        // - 항상 정수
        // - 그 다음 / i로 나누면 정확한 정수 결과
        // - 소수부 손실 없음, C(n,r) 수학적으로 항상 정수이므로 안전
        // -----------------------------
    }

    return res;
}

int main() {
    int T, N, M;
    cin >> T;

    while(T--) {
        cin >> N >> M;
        cout << combination(M, N) << '\n';
    }
}
