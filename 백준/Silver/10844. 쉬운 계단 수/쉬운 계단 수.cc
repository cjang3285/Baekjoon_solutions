/*
^ n축(y)
| 0  1  2   3   4   5   6   7   8   9   n = 4    
|  \/  \/  \/  \/  \/  \/ \/  \/  \/ 
| 0  1  2   3   4   5   6   7   8   9   n = 3    
|  \/ \/  \/  \/  \/  \/ \/  \/  \/ 
| 0  1  2   3   4   5   6   7   8   9   n = 2    17
|  \  \/  \/  \/  \/  \/ \/  \/  \/ 
| 0  1  2   3   4   5   6   7   8   9   n = 1    9
|------------------------------------------------> d축(x)
2(17-2)+2 이런 식의 계산은 틀림
17은 경로 총합이라 거기서 2를 빼는건 0과 9까지 도달한 두 경로를 통째로 n=1에서부터 지워버리는 거임
그러나 n=1에서 n=2로 가는 경로는 여전히 유효함. 그 경로를 토대로 새 경로를 찾아야하는데 빼버린 것. 
바로 오류가 발생.

dp로 먼저 계산하자. 위 그림으로 봤듯이 2차원 그래프가 나오므로 dp 배열 또한 2차원으로 한다.
dp[n(1~N)][d(0~9)]: 1층에서 n층의 d까지 오는 모든 경로의 수 즉 계단수의 개수를 값으로 가지는 배열로 정의한다
전역변수로 선언해 0으로 초기화
n=1일 때 d 0~9까지의 값을 초기값으로 입력
반복문으로 n=2일 때부터 dec 0~9까지의 값을 계산해 저장.
dp[n][d] = dp[n-1][d-1] + dp[n-1][d+1]

*/

#include<bits/stdc++.h>
using namespace std;
long long mod = 1000000000LL;

long long dp[101][11];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N; 
    cin >> N;
    
    // 1층 초기값 입력 
    // 1층에서 i가 0인 경우는 없으므로 스킵
    for(int i = 1; i <= 9; i++){
        dp[1][i] = 1LL; // 각 수는 계단 수이다. (공허참이므로)
    }
    // dp 배열 채우기 : n,d 지점까지 오는 모든 경로의 수 = 계단수의 개수 계산해 저장
    for(int n = 2; n <= N; n++){
        for(int d = 0; d <= 9; d++){
            if(d == 0){ // 0일때는 아랫층의 1에서만 올 수 있다
                dp[n][0] = dp[n-1][1];
            }
            else if(d == 9){ // 9일때는 아랫층의 8에서만 올 수 있다
                dp[n][9] = dp[n-1][8];
            }
            else{ 
                dp[n][d] = (dp[n-1][d-1] + dp[n-1][d+1]) % mod;
            }
        }
    }
    
    long long sum = 0;
    
    // N층의 각 수를 마지막 수로 갖는 계단수 개수를 전부 합산
    for(int d = 0; d <= 9; d++){
        sum = (sum + dp[N][d]) % mod;
    }
    cout << sum;
}