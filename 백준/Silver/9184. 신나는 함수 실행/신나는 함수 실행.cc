#include <bits/stdc++.h>
using namespace std;

// w(a,b,c) 함수의 DP 버전
// dp[a][b][c] = w(a,b,c)
// 9184 문제의 핵심: 재귀 정의를 DP 테이블로 치환
// dp 배열의 크기는 a, b, c가 0~20까지 가능하므로 21 21 21이다
int dp[21][21][21];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // ===============================
    // 1. Base Case (재귀 종료 조건)
    // a <= 0 or b <= 0 or c <= 0 -> w(a,b,c) = 1
    // DP에서는 이걸 배열 값으로 미리 박아둔다
    // 이렇게 하면 if문으로 재귀마다 체크할 필요가 없음
    // ===============================
    for (int a = 0; a <= 20; ++a)
        for (int b = 0; b <= 20; ++b)
            for (int c = 0; c <= 20; ++c)
                if (a == 0 || b == 0 || c == 0)
                    dp[a][b][c] = 1;

    // ===============================
    // 2. Fill DP table (재귀 -> 반복 구조)
    // dp[a][b][c]가 참조하는 것은 항상:
    //   - a-1, b-1, c-1 쪽 상태
    // 즉, 모든 참조는 이전 상태만 보고 계산
    // → 상태 그래프(의존 그래프)는 DAG
    // → 따라서 위상 정렬 순서대로 계산 가능
    // 3중 for문이 바로 이 위상 정렬
    // ===============================
    for (int a = 1; a <= 20; ++a) {
        for (int b = 1; b <= 20; ++b) {
            for (int c = 1; c <= 20; ++c) {
                // ===============================
                // 3. 점화식 (재귀를 DP로 치환)
                // a < b < c 인 경우:
                // dp[a][b][c] = dp[a][b][c-1] + dp[a][b-1][c-1] - dp[a][b-1][c]
                // otherwise:
                // dp[a][b][c] = dp[a-1][b][c] + dp[a-1][b-1][c] + dp[a-1][b][c-1] - dp[a-1][b-1][c-1]
                // ===============================
                if (a < b && b < c) {
                    dp[a][b][c] = dp[a][b][c-1]
                                  + dp[a][b-1][c-1]
                                  - dp[a][b-1][c];
                } else {
                    dp[a][b][c] = dp[a-1][b][c]
                                  + dp[a-1][b-1][c]
                                  + dp[a-1][b][c-1]
                                  - dp[a-1][b-1][c-1];
                }
            }
        }
    }

    // ===============================
    // 4. 입력 처리
    // -1 -1 -1 이 들어오면 종료
    // DP 구현의 핵심:
    // - a,b,c <= 0 -> 바로 1 반환
    // - a,b,c > 20 -> dp[20][20][20] 반환
    // - 나머지는 이미 채워둔 dp[a][b][c] 반환
    // ===============================
    int a, b, c;
    while (cin >> a >> b >> c) {
        if (a == -1 && b == -1 && c == -1)
            break;

        int ans;
        if (a <= 0 || b <= 0 || c <= 0) // base case
            ans = 1;
        else if (a > 20 || b > 20 || c > 20) // 범위 초과 -> 최대값 참조
            ans = dp[20][20][20];
        else
            ans = dp[a][b][c]; // DP 테이블에서 바로 꺼내기

        cout << "w(" << a << ", " << b << ", " << c << ") = " << ans << "\n";
    }

    return 0;
}

