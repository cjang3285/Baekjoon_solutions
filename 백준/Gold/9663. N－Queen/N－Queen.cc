#include <bits/stdc++.h>
using namespace std;

int N;
int cnt = 0;

/*
usedCol[c]:
→ 열 c에 이미 퀸이 있냐?
→ 같은 col에 두 퀸 못 놓으니까 필요
*/
bool usedCol[15];

/*
usedDiag1[d]:
→ '\' 방향 대각선 체크용
→ 이 대각선의 수학적 정의:
   row++, col++ 로 이동하면
   row - col 값이 변하지 않는다
→ 즉, 같은 '\' 대각선 위의 모든 칸은
   row - col 값이 동일하다

row - col 의 값 범위:
min: 0 - (N-1) = -(N-1)
max: (N-1) - 0 = +(N-1)

배열 인덱스는 음수가 안 되므로
+(N-1) 을 해서 전부 양수로 평행이동
→ 그래서:
   d = row - col + (N-1)

가능한 값(대각선) 개수:
-(N-1) ~ +(N-1)
→ 총 2N - 1 개
→ N ≤ 15 이므로 최대 29개
→ 그래서 배열 크기 30 (여유)
*/
bool usedDiag1[30];

/*
usedDiag2[d]:
→ '/' 방향 대각선 체크용
→ 이 대각선의 수학적 정의:
   row++, col-- 로 이동하면
   row + col 값이 변하지 않는다
→ 즉, 같은 '/' 대각선 위의 모든 칸은
   row + col 값이 동일하다

row + col 의 값 범위:
min: 0 + 0 = 0
max: (N-1) + (N-1) = 2N - 2

가능한 값(대각선) 개수:
0 ~ 2N - 2
→ 역시 총 2N - 1 개
→ 그래서 배열 크기 30
*/
bool usedDiag2[30];

/*
dfs(row):
→ row번째 행에 퀸 하나 놓는 함수
→ row 자체는 항상 하나씩 증가
→ 같은 row에는 어차피 하나만 두므로
   row 충돌 체크는 필요 없음
*/
void dfs(int row) {
    /*
    종료 조건:
    row == N 이면
    row 0 ~ N-1 까지
    모순 없이 다 놓았다는 뜻
    → 하나의 완전한 해
    */
    if (row == N) {
        cnt++;
        return;
    }

    /*
    현재 row에서
    가능한 모든 col을 시도
    → 세계선 분기 (DFS 트리)
    */
    for (int col = 0; col < N; col++) {
        int d1 = row - col + (N - 1); // '\' 그 대각선의 고유한 상수값
        int d2 = row + col;         // '/' 그 대각선의 고유한 상수값

        /*
            세 조건 중 하나라도 true면: 영역 충돌
            → 같은 열이거나
            → 같은 '\' 대각선이거나
            → 같은 '/' 대각선
            → 퀸끼리 서로 공격 가능
            우리는 "퀸이 어느 쪽으로 쏘는가"를 전혀 보지 않는다.
            (오른쪽 위? 왼쪽 아래? 이런 물리적 방향은 버린다)

            우리는 오직 이것만 본다:
            → "이 퀸이 어떤 '직선 족보'에 속해 있느냐"

            체스판의 대각선은 딱 두 패밀리뿐이다:
            1) 기울기 +1 계열:   row - col = 상수   → '\' 패밀리
            2) 기울기 -1 계열:   row + col = 상수   → '/' 패밀리

            각 퀸은 항상:
            - '\' 직선 하나
            - '/' 직선 하나
            를 동시에 점유한다.

            그리고 공격 판정은:
            "같은 직선 위에 있느냐?" 만 본다.

            서로를 향하느냐? 같은 방향으로 가느냐?
            → 전부 의미 없음.
            직선은 방향이 아니라 '집합'이기 때문.
        */
        if (usedCol[col] || usedDiag1[d1] || usedDiag2[d2])
            continue;

        /*
        이 자리는 안전
        → 상태 공간에 "퀸 하나 놓음"
        */
        usedCol[col] = true;
        usedDiag1[d1] = true;
        usedDiag2[d2] = true;

        // 다음 row로 내려감
        dfs(row + 1);

        /*
        백트래킹:
        방금 선택은
        다른 세계선 탐색 위해 되돌림
        */
        usedCol[col] = false;
        usedDiag1[d1] = false;
        usedDiag2[d2] = false;
    } // 여기까지 오면 실패 
      // => 갈 수 있는 자식이 하나도 없는 노드 : for 종료, dfs(row) 함수 끝
      // => 이 노드는 탐색트리에서 리프(막힌 리프)
      // => 더 내려갈 수 없으므로 현재 분기 종료
      
      // 이 행에서 더이상 퀸을 둘 수가 없다 
      // => 이 경로로는 해에 도달하지 못한다 
      // => 부모 dfs로 돌아간다  
      // => 암묵적 return
}

int main() {
    cin >> N;
    dfs(0);
    cout << cnt;
}

/*
========================
DFS 탐색 트리 예시 (N=4)
========================

각 노드 = dfs(row) 상태
각 간선 = col 선택

row = 0
|
|-- col 0
|    |
|    |-- row = 1
|    |    |-- col 2
|    |    |    |
|    |    |    |-- row = 2
|    |    |    |    (모든 col 충돌 → dead end)
|    |    |
|    |    |-- col 3
|    |         |
|    |         |-- row = 2
|    |              |-- col 1
|    |                   |
|    |                   |-- row = 3
|    |                        (모든 col 충돌 → dead end)
|
|-- col 1
|    |
|    |-- row = 1
|         |-- col 3
|              |
|              |-- row = 2
|                   |-- col 0
|                        |
|                        |-- row = 3
|                             |-- col 2
|                                  |
|                                  |-- row = 4  ★ 해 1
|
|-- col 2
|    |
|    |-- row = 1
|         |-- col 0
|              |
|              |-- row = 2
|                   |-- col 3
|                        |
|                        |-- row = 3
|                             |-- col 1
|                                  |
|                                  |-- row = 4  ★ 해 2
|
|-- col 3
     |
     |-- row = 1
          |-- col 0
          |    |
          |    |-- row = 2
          |         |-- col 2
          |              |
          |              |-- row = 3
          |                   (dead end)
          |
          |-- col 1
               |
               |-- row = 2
                    (dead end)

총 해 개수: 2
(실제 4-Queen 정답과 일치)

========================
이 트리의 본질
========================

- 각 깊이 = row
- 각 분기 = col 선택
- 가지가 잘리는 지점 = 
  usedCol / usedDiag1 / usedDiag2 중 하나 충돌

즉 이 코드는:

"4^4 전부 보는 게 아니라,
충돌하는 세계선은 생성 즉시 우주 삭제"

하는 구조의 탐색기.
*/

