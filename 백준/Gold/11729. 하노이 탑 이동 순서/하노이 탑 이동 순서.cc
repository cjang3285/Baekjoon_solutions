#include <bits/stdc++.h>
using namespace std;

/*
    hanoi(n, from, via, to)

    정석 정의:
    - n개의 원판을 from에서 to로 옮긴다
    - via는 경유지 역할

    핵심 분해 (교과서 표현):
    - 맨 아래 원판 1개
    - 그 위에 쌓인 n-1개의 원판

    핵심 재해석 (네가 잡은 관점):
    - '큰 덩어리 하나' (지금 반드시 옮기고 싶은 대상)
    - 그 위에 얹혀 있는 '작은 덩어리 하나'
    - 숫자 1, n-1은 중요하지 않고
      항상 [작은 덩어리 + 큰 덩어리 하나] 구조만 반복된다

    from / via / to 역시 좌표가 아니라
    "출발지 / 임시 보관소 / 목적지"라는 역할 이름일 뿐이다.
*/
void hanoi(int n, int from, int via, int to) {

    /*
        종료 조건: n == 0

        정석:
        - 옮길 원판이 없다

        개념적으로:
        - 지금 다루고 있는 '덩어리'가 더 이상 쪼개지지 않는다
        - 이 시점에서 나머지 원판들은 모두 지하에 묻혀 있고
          사고 대상에서 완전히 제외된다
    */
    if (n == 0) return;

    /*
        1단계: 위에 있는 n-1개를 치운다

        정석 표현:
        - n-1개의 원판을 from → via 로 옮긴다
        - 이때 to를 경유지로 사용한다

        덩어리 관점:
        - 큰 덩어리 하나를 옮기려면
          그 위에 얹힌 '작은 덩어리'를 통째로 치워야 한다
        - 이 호출이 시작되면
          우리는 작은 덩어리 문제로 완전히 들어간다
        - 원래 목표였던 큰 덩어리는
          지하로 묻혀 더 이상 신경 쓰지 않는다
        - 작은 덩어리도 함수 내부에서 작은, 큰 덩어리로 쪼개질 것이다.
        
        중요한 사실:
        - 이 작은 덩어리도 내부적으로
          **n=2 (작은, 큰 덩어리)에서 움직이던 구조를 그대로 반복한다**
          1 2
          1 3
          2 3 이게 작은, 큰 덩어리의 움직임이다.
    */
    hanoi(n - 1, from, to, via);

    /*
        2단계: 맨 아래 원판 1개 이동

        정석:
        - 가장 큰 원판을 from → to 로 옮긴다

        덩어리 관점:
        - 작은 덩어리가 전부 치워졌기 때문에
          이제 큰 덩어리 하나를 그대로 옮길 수 있다
        - 이 동작은 어떤 n에서도 정확히 한 번만 등장한다
        - n=1일 때는 이 줄 하나가 전체 문제다

        즉:
        - 모든 복잡함은 이 한 줄을 가능하게 만들기 위한 준비 과정이다
    */
    cout << from << ' ' << to << '\n';

    /*
        3단계: 치워둔 n-1개를 다시 얹는다

        정석 표현:
        - n-1개의 원판을 via → to 로 옮긴다
        - 이때 from을 경유지로 사용한다

        덩어리 관점:
        - 처음에 치워두었던 작은 덩어리를
          다시 큰 덩어리 위로 얹는다
        - 1단계에서 했던 작은 덩어리 문제를
          역할만 바꿔 그대로 한 번 더 실행하는 것뿐이다

        이게 가능한 이유:
        - 작은 덩어리는 처음부터 끝까지
          완전히 독립된 규칙을 가진 문제이기 때문이다
    */
    hanoi(n - 1, via, from, to);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    /*
        전체 이동 횟수 출력

        구조적으로 항상 반복되는 패턴:
        - 작은 덩어리 이동
        - 큰 덩어리 하나 이동
        - 작은 덩어리 이동

        그래서 이동 횟수는:
        T(n) = 2 * T(n-1) + 1

        이를 닫힌 형태로 쓰면:
        T(n) = 2^n - 1

        (1LL << n)의 의미:
        - 1LL : long long 타입의 1
        - << n : 비트를 왼쪽으로 n칸 이동
        - 결과적으로 2^n 과 같다

        따라서:
        (1LL << n) - 1 = 전체 최소 이동 횟수
    */
    cout << ((1LL << n) - 1) << '\n';

    /*
        실제 이동 출력

        이 시점부터 프로그램이 하는 일:
        - 항상 '지금 다루는 덩어리'만 생각한다
        - 나머지 원판들은 전부 지하에 묻혀 있다
        - 그래서 n이 커져도
          사고 구조는 절대 복잡해지지 않는다
    */
    hanoi(n, 1, 2, 3);
}