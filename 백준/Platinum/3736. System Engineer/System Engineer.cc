#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

// 이분 매칭 알고리즘은 작업 입력 순서와 상관없이 '언제나' 그 그래프에서 가능한 이론상 최대 매칭 수(Maximum Matching)
// 를 찾아냅니다. 작업 입력 순서에 따라 결과가 달라지지 않습니다.
// 베르주(Berge)의 정리 (수학적 근거)
// 그래프 이론에는 "매칭이 최대가 아니면, 반드시 증가 경로(Augmenting Path)가 존재한다"는 
// 베르주의 정리가 있습니다.
// 증가 경로: DFS로 찾으려 하는 '양보의 연쇄 고리'입니다.
// 만약 현재 매칭 수가 최대가 아니라면, 
// 어디선가 누군가는 반드시 양보를 통해 전체 매칭을 1개 늘릴 수 있는 경로가 존재한다는 것이 증명되어 있습니다.
// 코드는 for문을 돌며 모든 작업에 대해 이 경로를 전수 조사하므로, 
// 순서와 관계없이 더 이상 늘릴 수 없을 때까지 매칭을 추가하게 됩니다.
// E.G.
//    Case 1 (A부터 입력): 1. A가 서버 1 선택.
//                        2. B가 서버 1 원함 
//                        to A에게 양보 요청 
//                        to A가 서버 2로 이동 
//                        to (A-2, B-1) 총 2개
//    Case 2 (B부터 입력): 1. B가 서버 1 선택.
//                        2. A가 서버 1 원함 
//                        to B에게 양보 요청 
//                        to B는 갈 곳 없음(실패) 
//                        to A가 서버 2 선택 
//                        to (B-1, A-2) 총 2개
//    보시다시피 순서가 바뀌면 "누가 누구에게 양보하느냐"의 과정은 달라질 수 있지만, 
//    최종적으로 만들어지는 "매치의 수"는 똑같이 최댓값에 수렴하게 됩니다.


// 최대 노드 수 설정 (n은 최대 10,000)
const int MAX = 20001;
vector<int> adj[MAX]; // 인접 리스트: 작업이 어떤 서버와 연결될 수 있는지 알려주는 작업 i의 서버 번호 목록
int match[MAX];    // 서버가 어떤 작업과 연결되어 있는지 저장
bool visited[MAX];    // 한 번의 탐색(DFS)에서 해당 서버 v를 이미 방문했는지 체크

// DFS 함수: 작업 u를 담당할 수 있는 서버들 고유번호들을 v : adj[u]로 각각 시도해보며 
// 작업 u를 감당가능한 서버 v를 찾아보자.
bool dfs(int u) {                     // 작업 u를 입력하면
    for (int v : adj[u]) {              // 작업 u가 처리될 수 있는 서버들 고유번호들을 순회하며 빈 서버가 있는지 보자.
        if (visited[v]) continue;
        visited[v] = true; 
        // visited[v] = true는 "이번 작업 u의 대타를 찾는 과정에서, 이미 서버 v한테 물어봤다는 뜻입니다. 
        
        // n번째 작업이 한 서버 v와 매칭이 됐다고 합시다.
        // n+1번째 작업 입장에서 n번째 작업이 매칭된 서버 v가 본인을 처리할 수 있는 유일한 서버라고 합시다.
        // 이러면 최대한 매칭 수를 늘리기 위해 n번째 작업이 양보를 해줘야 합니다.
        // 이때 n번째 작업 매칭 후 visited를 초기화하지 않았다면 n+1번째 작업 매칭 때에는 서버 v가 visited이므로
        // 양보 요청을 못하게 됩니다. 즉 최대 매칭 수를 구하지 못하게 됩니다.
        // 그러므로 visited는 매 작업 매칭 전에 이번 작업이 이전 작업들에게 양보요청을 보내려면 초기화되어야 합니다. 
        
        
        // visited은 매칭 기록이 아닙니다. 매칭 기록은 match[서버번호]로 파악합니다.
        // 1. 서버 v가 처리 중인 작업이 없으면 u를 담당해준다.             <= match[v] == -1
        // 2. 서버 v가 처리 중인 작업(match[v]) u*가 있으면             <= match[v] != -1
        // u*를 다른 서버가 담당하게 한다 <= dfs(match[v])
        // 만약 담당해줄 다른 서버를 끝내 못 찾으면, 
        // 서버 v가 처리 중인 작업 있었고 대타해줄 서버도 못 구했으니 
        // 작업 u는 서버를 배정받지 못하고 노는 작업이 된다.
        // return false;
        
        // 서버 v가 비어있었으면, v --- u로 매칭되고
        // 차있더라도 v가 담당했던 작업 u*(u 아님)을 대타해줄 서버 v*(v 아님)를 찾았다면,
        // v* --- u* <= v가 담당하던 u*를 처리해줄 대타 서버 v*를 구했고
        //  v --- u <= v가 u를 담당하게 할 수 있습니다.
        // 혼자가 된 서버 v를 작업 u가 담당하게 한다. <= match[v] = u;
        
        if (match[v] == -1 || dfs(match[v])) {
            match[v] = u; // 서버 v를 작업 u에게 배정
            return true;  // 매칭 성공!
        }
    }
    return false; // 끝내 매칭 실패
}

int main() {
    int n;
    // EOF(파일 끝)까지 반복해서 입력받음
    while (scanf("%d", &n) != EOF) {
        // 1. 초기화: 매 케이스마다 그래프와 매칭 기록을 비워야 함
        for (int i = 0; i < n; i++) // 모든 작업들에 대해 서버와 매칭한 그래프 지우기
            adj[i].clear(); // 작업 i가 어떤 서버와 매칭 가능한지를 알려주는 인접 리스트 초기화.
        
        fill(match, match + MAX, -1); // 서버 입장에서 작업과 매칭된 정보 리스트 -1로 초기화

        // 2. 입력 처리: "0: (3) 4 5 6" 형태를 파싱 
        //    형식은 작업번호: (해당 작업을 처리할 수 있는 서버 개수) 해당 작업을 처리할 수 있는 서버 번호들
        
        for (int i = 0; i < n; i++) { // 한 데이터 세트에 대해 작업은 총 n개이므로 n개의 작업에 대한 정보를 입력받는다.
            int u, count;              // 이번에 입력받는 작업 번호 u
            scanf("%d: (%d)", &u, &count); // 이번에 입력받은 작업을 처리할 수 있는 서버 수 count  
            for (int j = 0; j < count; j++) {
                int v; // 이번에 입력받는 작업을 처리할 수 있는 서버들의 고유 번호 v
                scanf("%d", &v);
                adj[u].push_back(v); // 작업 u에서 서버 v로의 간선 추가
            }
        }

        // 3. 이분 매칭 수행
        int totalMatches = 0;
        for (int i = 0; i < n; i++) { // i는 작업 번호
            // 매 작업마다 서버 v가 점유 상태인지 알게 해주는 visited 배열 초기화하고 다시 매칭 
            // => 매 작업마다 visited를 초기화해주는 이유
            // $u$가 $v$에게 양보 요청 $\to$ $v$의 주인 $u'$이 다른 서버 $v'$에게 양보 요청...
            // 이 과정에서 다시 $v$에게 돌아오는 **순환(Cycle)**이 생기면 프로그램이 멈추지 않습니다.
            // 반대로 visited를 사용하고 continue 문 넣으면? 한번 양보요청으로 
            // v  x  1   7  ...  23   1  양보요청 흐름 : 0 -> 1 -> 8 -> 7 -> ... -> 23 -> 53 -> 1 (첫 양보요청으로 돌아옴)
            // u  0  8   2  ...  53   8  이런 식으로 u가 다음 u* (코드상에선 dfs(match[v]))에게 
            // 계속 양보요청을 보내다보면 작업 53이 서버 1에게 양보요청을 하면서 
            // 8번 작업이 또 7번 서버에게 양보요청... 하는 무한 사이클이 생겨버림. 
            // 그럼 이런 상황에서 continue가 있었다면 매번 양보요청(e.g. dfs(match[1]))을 하기 전에 
            // visited에 작업 i에 대해 매칭하는 과정에서 양보요청했던 모든 서버 번호가 
            // visited에 저장되어있으니 53번 작업이 또 1번 서버에 양보요청을 할 수가 없게됨. 
            // 왜냐면 0번 작업이 처음 양보요청 보낸 곳이 1번 서버여서 이미 visited에 1번이 true로 기록되었기 때문.
            // 53번 작업을 매칭할 서버 찾는 중에 if (visited[v]) continue;에 의해서 
            // visited 처리됐던 1번 서버는 스킵되어 양보요청을 보내는 조건절까지 진입하지 못하기 때문임. 
            // 만약 53번을 대신 맡아줄 서버가 없으면(adj[53]가 동난 경우) 끝내 실패하여 false를 반환하게 될 것임. 
            // 0이 1번 서버에 양보요청을 보내면서 여러 분기가 생겼을 거라 가정해보자. 
            // 중간 중간에 트리형식으로 계속 다른 서버의 매칭되어있던 작업들도 가지 치듯이 
            // 양보요청을 다른 서버들에게 보낼 건데 visited 덕분에 사이클 구조는 생기지 못하게 됨. 
            // 만약 사이클 즉 다시 첫 양보요청한 노드로 돌아오게 되면 visited에 의해 인접 리스트가 동나고
            // 실패로 결론난다. 
            // 이런 문제에서 모든 나뭇가지들은 그 끝이 실패 혹은 성공(match[v] == -1 빈 서버)으로 끝나면서
            // 그 결론을 맨 처음 dfs(i)가 반환하여 totalMatches++ 할지 말지 할 수 수 있게 되는 거임.

            fill(visited, visited + MAX, 0);
            
            if (dfs(i)) { // 매 작업에 대해 하나의 서버를 매칭 시도. 
                // dfs 함수 내에서 해당 작업을 처리 가능한 고유번호의 서버 v가 비었으면 바로 매칭 성공.
                // 안 비었으면, 서버 v가 담당 중인 작업 u*을 다른 서버 v*가 대타로 담당해줄 수 있는지 보고 
                // 가능하면 담당하던 작업 u*을 대타 서버 v*랑 매칭시킨다.
                // 그러면 서버 v에게 여유가 생겼으니 서버를 구하던 u 작업을 비워진 서버 v와 매칭하게 된다.
                
                // 재귀 dfs이기 때문에 연쇄적으로 작업들이 대타를 구하고 끝에서 대타가 구해지면 스택이 돌아오면서 매칭이 연달아 성공할 수도 있다.  
                // 재귀의 연쇄 반응: dfs(match[v])가 단순히 한 명의 대타를 찾는 게 아니라, 
                // "대타의 대타의 대타..." 즉 "dfs(match[v])의 dfs(match[v])의 dfs(match[v])의 dfs(match[v])" 
                // 까지 타고 들어가서 결국 마지막에 빈 서버(match[v] == -1)를 찾아내면, 
                // 그 성공 신호(true)가 돌아오며 줄줄이 매칭을 갱신한다.
                
                totalMatches++;
            }
        }

        // 4. 결과 출력
        printf("%d\n", totalMatches);
    }
    return 0;
}